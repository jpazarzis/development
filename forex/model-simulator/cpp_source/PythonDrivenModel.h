///////////////////////////////////////////////////////////////////////////////
//
// PythonDrivenModel.h
//
// Author        : John Pazarzis
// Creation date : Sat 02 Nov 2013 08:25:13 AM EDT
//
// Summary
//      Represents a model that its BUY/SELL signal is generated by an external
//      Python script which will be called back. All the data processing and
//      genetic algorithm related logic will be performed in the C++ level using
//      the classes used for any other model that is completely described in
//      C++. The difference here is that just the signal is decided in Python.
//
// Notes
//     
///////////////////////////////////////////////////////////////////////////////


#ifndef PYTHONDRIVENMODEL_INCLUDED
#define PYTHONDRIVENMODEL_INCLUDED

#include "Model.h"
#include "CloneableDouble.h"
#include "TickPool.h"
#include "FitnessStatistics.h"
#include "std_include.h"
#include "PythonSignalCaller.h"

#define BUY_SIGNAL 1
#define SELL_SIGNAL -1
#define DO_NOTHING_SIGNAL 0

class PythonDrivenModel : public Model
{
    public:

        PythonDrivenModel()
        {
        }

        virtual ~PythonDrivenModel() 
        {
        }

        // Specifies the python file containing the code of the 
        // process tick function. Based in the parameters of the process
        // tick function we populate the vector of the optimizable parameters
        // while we also initialize the standards fields which are stop loss
        // take profit and expiration minutes that will be later used for the
        // creation of the order
        void set_python_module(const std::string& module_name)
        {

            _stop_loss = CloneableDouble(8, 22, 2);
            _take_profit = CloneableDouble(10, 22, 2);
            _expriration_minutes = CloneableDouble(10, 300, 1);

            _signal_caller.set_module(module_name);
            _optimizable_parameters.clear();
            for(int i = 0; i < _signal_caller.count_optimizable_parameters(); ++i)
            {
                _optimizable_parameters.push_back(CloneableDouble(1,100,1));
            }

            initialize_optimizable_fields();
        }

        virtual std::string to_string() const 
        {
            return "Object of type PythonDrivenModel";
        }

        PythonDrivenModel(const PythonDrivenModel& other) = delete;
        
        PythonDrivenModel& operator=(const PythonDrivenModel& other) = delete;

        virtual void process(const Tick& tick)
        {
            // do nothing since 
        }


        // We allow the called to specify all the variables of the model by
        // hand. Used for forward testing.
        void set_values(double stop_loss, 
                        double profit_take, 
                        double expriration_minutes, 
                        const std::vector<double>& values)
        {
            _stop_loss.read_from_double(stop_loss);
            _take_profit.read_from_double(profit_take);
            _expriration_minutes.read_from_double(expriration_minutes);

            _optimizable_parameters.clear();
            for(auto v: values)
            {
                CloneableDouble od;
                od.read_from_double(v);
                _optimizable_parameters.push_back(od);    
            }

            initialize_optimizable_fields();
        }


        // Calculates the fitness of the model that will be later used by the
        // genetic algorithm or it will the forward tester to report the
        // behavior of the model.
        //
        // Before calling this function you should first load the ticks to the
        // tick pool, which is a singleton that can be used from any object in
        // the system. 
        //
        // Goes through all the ticks loaded in the pool calling the process
        // tick function which in turn calls the python implemented logic in
        // the specified module..
        //
        // This function should called both for optimizing and forward testing
        void calculate_fitness()
        {
            TickPool& tp = TickPool::singleton();
            const int number_of_ticks = tp.size();
            std::vector<Order*> orders;


            for(register int i = 0; i < number_of_ticks; ++i)
            {
                process_tick(tp[i], orders, i);
            }



            _fitness_statistics = FitnessStatistics::make(orders);
            set_fitness(_fitness_statistics.fitness());

            for(auto order_ptr : orders)
            {
                Order::release(order_ptr);
            }
        }

        std::string get_full_description() const
        {
            std::string strg;
            strg += sformat("id:", "%20s");
            strg += sformat((int)_id, "%20d");
            strg += "\n";
            strg += sformat("expriration minutes:", "%20s");
            strg += sformat((double)_expriration_minutes, "%20.5f");
            strg += "\n";
            strg += sformat("stop loss:", "%20s");
            strg += sformat((double)_stop_loss, "%20.5f");
            strg += "\n";
            strg += sformat("profit take:", "%20s");
            strg += sformat((double)_take_profit, "%20.5f");
            strg += "\n";
            strg += _fitness_statistics.get_full_description();
            return strg;
        }

        

    protected:
        
        virtual void initialize_optimizable_fields()
        {
            clear_opimizable_fields();
            add_optimizable_field(&_stop_loss);
            add_optimizable_field(&_take_profit);
            add_optimizable_field(&_expriration_minutes);
            
            for(auto of: _optimizable_parameters)
            {
                add_optimizable_field(&of);
            }
        }

    private:


    // Calls the Python signal generator providing it with the "standard" data
    // that all signal generators need and the user specific parameters.  The
    // number of the user specific parameters is already determined by counting
    // the parameters of the Python function and their type always will be
    // double.
    void process_tick(const Tick& tick, std::vector<Order*>& orders, int current_tick_index)
    {
            const int year = tick.timestamp().date().year();
            const int month = tick.timestamp().date().month();
            const int day  = tick.timestamp().date().day();
            const int hour = tick.timestamp().time_of_day().hours();
            const int minute = tick.timestamp().time_of_day().minutes();
            const int second = tick.timestamp().time_of_day().seconds();

            vector<double> op;
            for(auto p:_optimizable_parameters)
            {
                op.push_back((double)p);
            }

            const int signal = _signal_caller.get_signal( 
                                          year,
                                          month,
                                          day, 
                                          hour, 
                                          minute, 
                                          second,
                                          tick.bid(), 
                                          tick.ask(), 
                                          op);


            assert(signal == SELL_SIGNAL || signal == DO_NOTHING_SIGNAL || signal == BUY_SIGNAL);

            

            if(signal == DO_NOTHING_SIGNAL)
            {
                return;
            }

            Order* pOrder = NULL;

            if(signal == SELL_SIGNAL)
            {
                    pOrder = Order::make(SELL, 
                                        (double)_stop_loss, 
                                        (double)_take_profit, 
                                        tick, 
                                        (int)((double)_expriration_minutes));
            }
            else if(signal == BUY_SIGNAL)
            {
                    pOrder = Order::make(BUY, 
                                        (double)_stop_loss, 
                                        (double)_take_profit, 
                                        tick, 
                                        (int)((double)_expriration_minutes));
            }

            assert(NULL != pOrder);
            orders.push_back(pOrder);
            pOrder->process_until_closing(current_tick_index);
        }

        PythonSignalCaller _signal_caller;
        // this are standard optimizables
        CloneableDouble _stop_loss; 
        CloneableDouble _take_profit;
        CloneableDouble _expriration_minutes; 

        FitnessStatistics _fitness_statistics;

        // user defined optimizable will be stored here
        std::vector<CloneableDouble> _optimizable_parameters;
};

#endif // PYTHONDRIVENMODEL_INCLUDED
